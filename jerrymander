__author__ = 'Emma, Jolie, Pratyush'

from collections import deque
import random

class BacktrackingGerrymander:
    TARGET_SIZE = 9   # Target size is the number of voters wanted per district, can edit but will have to edit the e value of the other code

    def backtrack(self, electorate, party):  # kinda like an init?
        graph = electorate.graph                    #adjacent structure
        voters = electorate.number_of_voters()      #total number of voters
        d = electorate.district_size()              #N/TARGET_size

        def is_connected(group):  # Checks connectivity of a set, no one disjointed
            start = next(iter(group))  #iterates through group takes one node from it
            visited = {start}           # tracks nodes visited
            queue = deque([start])      # the nodes to explore next
            while queue:                #Best First Search
                u = queue.popleft()     #take node out of queue
                for w in graph.neighbors(u):#looks at adjacent node
                    if w in group and w not in visited: #only looks at the edges of nodes that are not visited and inside the district(w group)
                        visited.add(w)
                        queue.append(w) #add valid neighbors to visited and queue to then check its neighbors
            return len(visited) == len(group)  #if every node is reached return True

        def score(group):
            """Counts how many voters in the group vote for the target party"""
            votes = sum(electorate.votes[i] == party for i in group)
            opp = self.TARGET_SIZE - votes
            return votes, opp

        def grow(start_node, used):  # BFS
            target = self.TARGET_SIZE
            queue = [start_node]
            group = {start_node}
            while queue and len(group) < target:  # nodes < 9
                node = queue.pop(0)
                neighbors = list(graph.neighbors(node))
                random.shuffle(neighbors)  # random bfs
                for n in neighbors:  # eligible neighbors
                    if n not in group and n not in used:
                        group.add(n)
                        queue.append(n)
                        if len(group) == target:  # already have 9 voters
                            break
            if len(group) != target:  # dead end, give up
                return None
            return [group] if is_connected(group) else None  # make sure real district

        def build(used, districts):     #  tries to create all districts with grow function
            if len(districts) == d:     # if all districts made return the list of districts
                return districts

            for seed in range(voters):  #loop through all voters
                if seed in used:        #skip seeds already in a district
                    continue

                built_group = grow(seed, used)  # jolie changed this
                if not built_group:     #if that doesn't work try another seed(voter)
                    continue

                gset = built_group[0]      #if the built_group works add to list of districts
                districts.append(list(gset))
                used |= gset               #have all voters in district set to used

                result = build(used, districts) #now recursively build a new district
                if result:                  # if it works return result
                    return result

0                used -= gset        # if the recursion doesn't work remove the voters from district and remove from used list
                districts.pop()
            return None     # if every voter fails return none
        return build(set(), []) # makes a list starting with no used voters and no districts

    def best_of_trials(self, electorate, party):
        trials = 5 # hard for my computer you can increase for a better result
        best = None
        best_wins = -1

        for _ in range(trials):
            gm = BacktrackingGerrymander()
            districts = gm.backtrack(electorate, party)
            wins = electorate.get_wins(districts, party)

            if wins > best_wins:
                best = districts
                best_wins = wins

                # early exit if  party wins
                if wins > self.TARGET_SIZE // 2:
                    break

        return best
"""
1. How does your algorithm work? Explain clearly, using diagrams if they help.
    Our algorithm does a recursive random BFS. The BFS finds a working district of nine, which is then repeated till all voters are in one of the nine districts. 
    This process is then repeated based on the number of trials specified, and it returns the trial with the best results for the party given. 
    Sometimes it has a harder time finding districts that work, and it is best just to run the program again.
2. How effective is your algorithm on Electorates of various sizes(9,19,29)
    It is not effective for any of the sizes. The running time drastically increases as the BFS will take longer to find all the members of a district, and the recursion will have to happen more, with more districts needing to be created
3. What difficulties did you encounter and how did you overcome them?
    I had a hard time testing my program with how long it takes to run. I was struggling to come up with a faster way for it to run. Originally, 
    I tried to make it so that the program would prioritize districts with the party having a small majority, and if that isn't possible, try grouping all the enemy party, then just giving up and finding a working district. 
    I either executed this incorrectly and/or it took too long, so I pivoted to doing trials.  
4. How did your team work together to solve this problem? How can you improve this process in future projects?"""
    We all met up outside of class to come up with a game plan. Emma and Jolie worked through strategies to tackle the problem.
    Emma ended up creating a recursive function with another recursive function for gerrymandering. Jolie edited it into a more efficient function using BFS for the grow function.
    For future projects, this process would be improved a bit if we procrastinated a bit less.
